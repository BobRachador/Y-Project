{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { setLogLevel as _setLogLevel, connectFirestoreEmulator, initializeFirestore, runTransaction, getApp, getFirestore, collection, collectionGroup, doc, getDoc, getDocs, getCount, deleteDoc, setDoc, updateDoc, writeBatch, terminate as _terminate } from '@react-native-firebase/app/lib/internal/web/firebaseFirestore';\nimport { guard, getWebError, emitEvent } from '@react-native-firebase/app/lib/internal/web/utils';\nimport { objectToWriteable, readableToObject, parseDocumentBatches } from './convert';\nimport { buildQuery } from './query';\nfunction rejectWithCodeAndMessage(code, message) {\n  return Promise.reject(getWebError({\n    code: code,\n    message: message\n  }));\n}\nfunction documentSnapshotToObject(snapshot) {\n  var exists = snapshot.exists();\n  var out = {\n    metadata: [false, false],\n    path: snapshot.ref.path,\n    exists: exists\n  };\n  if (exists) {\n    out.data = objectToWriteable(snapshot.data() || {});\n  }\n  return out;\n}\nfunction querySnapshotToObject(snapshot) {\n  return {\n    source: 'get',\n    excludesMetadataChanges: true,\n    changes: [],\n    metadata: [false, false],\n    documents: snapshot.docs.map(documentSnapshotToObject)\n  };\n}\nvar emulatorForApp = {};\nvar firestoreInstances = {};\nvar appInstances = {};\nvar transactionHandler = {};\nvar transactionBuffer = {};\nfunction getCachedAppInstance(appName) {\n  return appInstances[appName] ??= getApp(appName);\n}\nfunction createFirestoreKey(appName, databaseId) {\n  return `${appName}:${databaseId}`;\n}\nfunction getCachedFirestoreInstance(appName, databaseId) {\n  var firestoreKey = createFirestoreKey(appName, databaseId);\n  var instance = firestoreInstances[firestoreKey];\n  if (!instance) {\n    instance = getFirestore(getCachedAppInstance(appName), databaseId);\n    if (emulatorForApp[firestoreKey]) {\n      connectFirestoreEmulator(instance, emulatorForApp[firestoreKey].host, emulatorForApp[firestoreKey].port);\n    }\n    firestoreInstances[firestoreKey] = instance;\n  }\n  return instance;\n}\nexport default {\n  setLogLevel: function () {\n    var _setLogLevel2 = _asyncToGenerator(function* (logLevel) {\n      if (logLevel === 'debug' || logLevel === 'error') {\n        _setLogLevel(logLevel);\n      } else {\n        _setLogLevel('silent');\n      }\n    });\n    function setLogLevel(_x) {\n      return _setLogLevel2.apply(this, arguments);\n    }\n    return setLogLevel;\n  }(),\n  loadBundle: function loadBundle() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n  clearPersistence: function clearPersistence() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n  waitForPendingWrites: function () {\n    var _waitForPendingWrites = _asyncToGenerator(function* () {\n      return null;\n    });\n    function waitForPendingWrites() {\n      return _waitForPendingWrites.apply(this, arguments);\n    }\n    return waitForPendingWrites;\n  }(),\n  disableNetwork: function disableNetwork() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n  enableNetwork: function enableNetwork() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n  useEmulator: function useEmulator(appName, databaseId, host, port) {\n    return guard(_asyncToGenerator(function* () {\n      var firestore = getCachedFirestoreInstance(appName, databaseId);\n      connectFirestoreEmulator(firestore, host, port);\n      var firestoreKey = createFirestoreKey(appName, databaseId);\n      emulatorForApp[firestoreKey] = {\n        host: host,\n        port: port\n      };\n    }));\n  },\n  settings: function settings(appName, databaseId, _settings) {\n    return guard(function () {\n      var instance = initializeFirestore(getCachedAppInstance(appName), _settings, databaseId);\n      firestoreInstances[appName] = instance;\n    });\n  },\n  terminate: function terminate(appName, databaseId) {\n    return guard(_asyncToGenerator(function* () {\n      var firestore = getCachedFirestoreInstance(appName, databaseId);\n      yield _terminate(firestore);\n      return null;\n    }));\n  },\n  namedQueryOnSnapshot: function namedQueryOnSnapshot() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n  collectionOnSnapshot: function collectionOnSnapshot() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n  collectionOffSnapshot: function collectionOffSnapshot() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n  namedQueryGet: function namedQueryGet() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n  collectionCount: function collectionCount(appName, databaseId, path, type, filters, orders, options) {\n    return guard(_asyncToGenerator(function* () {\n      var firestore = getCachedFirestoreInstance(appName, databaseId);\n      var queryRef = type === 'collectionGroup' ? collectionGroup(firestore, path) : collection(firestore, path);\n      var query = buildQuery(queryRef, filters, orders, options);\n      var snapshot = yield getCount(query);\n      return {\n        count: snapshot.data().count\n      };\n    }));\n  },\n  collectionGet: function collectionGet(appName, databaseId, path, type, filters, orders, options, getOptions) {\n    if (getOptions && getOptions.source === 'cache') {\n      return rejectWithCodeAndMessage('unsupported', 'The source cache is not supported in the lite SDK.');\n    }\n    return guard(_asyncToGenerator(function* () {\n      var firestore = getCachedFirestoreInstance(appName, databaseId);\n      var queryRef = type === 'collectionGroup' ? collectionGroup(firestore, path) : collection(firestore, path);\n      var query = buildQuery(queryRef, filters, orders, options);\n      var snapshot = yield getDocs(query);\n      return querySnapshotToObject(snapshot);\n    }));\n  },\n  documentOnSnapshot: function documentOnSnapshot() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n  documentOffSnapshot: function documentOffSnapshot() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n  persistenceCacheIndexManager: function persistenceCacheIndexManager() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n  documentGet: function documentGet(appName, databaseId, path, getOptions) {\n    return guard(_asyncToGenerator(function* () {\n      if (getOptions && getOptions.source === 'cache') {\n        return rejectWithCodeAndMessage('unsupported', 'The source cache is not supported in the lite SDK.');\n      }\n      var firestore = getCachedFirestoreInstance(appName, databaseId);\n      var ref = doc(firestore, path);\n      var snapshot = yield getDoc(ref);\n      return documentSnapshotToObject(snapshot);\n    }));\n  },\n  documentDelete: function documentDelete(appName, databaseId, path) {\n    return guard(_asyncToGenerator(function* () {\n      var firestore = getCachedFirestoreInstance(appName, databaseId);\n      var ref = doc(firestore, path);\n      yield deleteDoc(ref);\n      return null;\n    }));\n  },\n  documentSet: function documentSet(appName, databaseId, path, data, options) {\n    return guard(_asyncToGenerator(function* () {\n      var firestore = getCachedFirestoreInstance(appName, databaseId);\n      var ref = doc(firestore, path);\n      var setOptions = {};\n      if ('merge' in options) {\n        setOptions.merge = options.merge;\n      } else if ('mergeFields' in options) {\n        setOptions.mergeFields = options.mergeFields;\n      }\n      yield setDoc(ref, readableToObject(firestore, data), setOptions);\n    }));\n  },\n  documentUpdate: function documentUpdate(appName, databaseId, path, data) {\n    return guard(_asyncToGenerator(function* () {\n      var firestore = getCachedFirestoreInstance(appName, databaseId);\n      var ref = doc(firestore, path);\n      yield updateDoc(ref, readableToObject(firestore, data));\n    }));\n  },\n  documentBatch: function documentBatch(appName, databaseId, writes) {\n    return guard(_asyncToGenerator(function* () {\n      var firestore = getCachedFirestoreInstance(appName, databaseId);\n      var batch = writeBatch(firestore);\n      var writesArray = parseDocumentBatches(firestore, writes);\n      for (var parsed of writesArray) {\n        var type = parsed.type,\n          path = parsed.path;\n        var ref = doc(firestore, path);\n        switch (type) {\n          case 'DELETE':\n            batch.delete(ref);\n            break;\n          case 'UPDATE':\n            batch.update(ref, parsed.data);\n            break;\n          case 'SET':\n            var options = parsed.options;\n            var setOptions = {};\n            if ('merge' in options) {\n              setOptions.merge = options.merge;\n            } else if ('mergeFields' in options) {\n              setOptions.mergeFields = options.mergeFields;\n            }\n            batch.set(ref, parsed.data, setOptions);\n            break;\n        }\n      }\n      yield batch.commit();\n    }));\n  },\n  transactionGetDocument: function transactionGetDocument(appName, databaseId, transactionId, path) {\n    if (!transactionHandler[transactionId]) {\n      return rejectWithCodeAndMessage('internal-error', 'An internal error occurred whilst attempting to find a native transaction by id.');\n    }\n    return guard(_asyncToGenerator(function* () {\n      var firestore = getCachedFirestoreInstance(appName, databaseId);\n      var docRef = doc(firestore, path);\n      var tsx = transactionHandler[transactionId];\n      var snapshot = yield tsx.get(docRef);\n      return documentSnapshotToObject(snapshot);\n    }));\n  },\n  transactionDispose: function transactionDispose(appName, databaseId, transactionId) {\n    delete transactionHandler[transactionId];\n  },\n  transactionApplyBuffer: function transactionApplyBuffer(appName, databaseId, transactionId, commandBuffer) {\n    if (transactionHandler[transactionId]) {\n      transactionBuffer[transactionId] = commandBuffer;\n    }\n  },\n  transactionBegin: function transactionBegin(appName, databaseId, transactionId) {\n    return guard(_asyncToGenerator(function* () {\n      var firestore = getCachedFirestoreInstance(appName, databaseId);\n      try {\n        yield runTransaction(firestore, function () {\n          var _ref12 = _asyncToGenerator(function* (tsx) {\n            transactionHandler[transactionId] = tsx;\n            emitEvent('firestore_transaction_event', {\n              eventName: 'firestore_transaction_event',\n              body: {\n                type: 'update'\n              },\n              appName: appName,\n              databaseId: databaseId,\n              listenerId: transactionId\n            });\n            function getBuffer() {\n              return transactionBuffer[transactionId];\n            }\n            var buffer = yield new Promise(function (resolve) {\n              var interval = setInterval(function () {\n                var buffer = getBuffer();\n                if (buffer) {\n                  clearInterval(interval);\n                  resolve(buffer);\n                }\n              }, 100);\n            });\n            for (var serialized of buffer) {\n              var path = serialized.path,\n                type = serialized.type,\n                data = serialized.data;\n              var docRef = doc(firestore, path);\n              switch (type) {\n                case 'DELETE':\n                  tsx.delete(docRef);\n                  break;\n                case 'UPDATE':\n                  tsx.update(docRef, readableToObject(firestore, data));\n                  break;\n                case 'SET':\n                  var options = serialized.options;\n                  var setOptions = {};\n                  if ('merge' in options) {\n                    setOptions.merge = options.merge;\n                  } else if ('mergeFields' in options) {\n                    setOptions.mergeFields = options.mergeFields;\n                  }\n                  tsx.set(docRef, readableToObject(firestore, data), setOptions);\n                  break;\n              }\n            }\n          });\n          return function (_x2) {\n            return _ref12.apply(this, arguments);\n          };\n        }());\n        emitEvent('firestore_transaction_event', {\n          eventName: 'firestore_transaction_event',\n          body: {\n            type: 'complete'\n          },\n          appName: appName,\n          databaseId: databaseId,\n          listenerId: transactionId\n        });\n      } catch (e) {\n        emitEvent('firestore_transaction_event', {\n          eventName: 'firestore_transaction_event',\n          body: {\n            type: 'error',\n            error: getWebError(e)\n          },\n          appName: appName,\n          databaseId: databaseId,\n          listenerId: transactionId\n        });\n      }\n    }));\n  }\n};","map":{"version":3,"names":["setLogLevel","connectFirestoreEmulator","initializeFirestore","runTransaction","getApp","getFirestore","collection","collectionGroup","doc","getDoc","getDocs","getCount","deleteDoc","setDoc","updateDoc","writeBatch","terminate","guard","getWebError","emitEvent","objectToWriteable","readableToObject","parseDocumentBatches","buildQuery","rejectWithCodeAndMessage","code","message","Promise","reject","documentSnapshotToObject","snapshot","exists","out","metadata","path","ref","data","querySnapshotToObject","source","excludesMetadataChanges","changes","documents","docs","map","emulatorForApp","firestoreInstances","appInstances","transactionHandler","transactionBuffer","getCachedAppInstance","appName","createFirestoreKey","databaseId","getCachedFirestoreInstance","firestoreKey","instance","host","port","_setLogLevel2","_asyncToGenerator","logLevel","_x","apply","arguments","loadBundle","clearPersistence","waitForPendingWrites","_waitForPendingWrites","disableNetwork","enableNetwork","useEmulator","firestore","settings","namedQueryOnSnapshot","collectionOnSnapshot","collectionOffSnapshot","namedQueryGet","collectionCount","type","filters","orders","options","queryRef","query","count","collectionGet","getOptions","documentOnSnapshot","documentOffSnapshot","persistenceCacheIndexManager","documentGet","documentDelete","documentSet","setOptions","merge","mergeFields","documentUpdate","documentBatch","writes","batch","writesArray","parsed","delete","update","set","commit","transactionGetDocument","transactionId","docRef","tsx","get","transactionDispose","transactionApplyBuffer","commandBuffer","transactionBegin","_ref12","eventName","body","listenerId","getBuffer","buffer","resolve","interval","setInterval","clearInterval","serialized","_x2","e","error"],"sources":["C:/Users/richard.5935/Downloads/Yzon/node_modules/@react-native-firebase/firestore/lib/web/RNFBFirestoreModule.js"],"sourcesContent":["import {\n  setLogLevel,\n  connectFirestoreEmulator,\n  initializeFirestore,\n  runTransaction,\n  getApp,\n  getFirestore,\n  collection,\n  collectionGroup,\n  doc,\n  getDoc,\n  getDocs,\n  getCount,\n  deleteDoc,\n  setDoc,\n  updateDoc,\n  writeBatch,\n  terminate,\n} from '@react-native-firebase/app/lib/internal/web/firebaseFirestore';\nimport { guard, getWebError, emitEvent } from '@react-native-firebase/app/lib/internal/web/utils';\nimport { objectToWriteable, readableToObject, parseDocumentBatches } from './convert';\nimport { buildQuery } from './query';\n\nfunction rejectWithCodeAndMessage(code, message) {\n  return Promise.reject(\n    getWebError({\n      code,\n      message,\n    }),\n  );\n}\n\n// Converts a Firestore document snapshot to a plain object.\nfunction documentSnapshotToObject(snapshot) {\n  const exists = snapshot.exists();\n\n  const out = {\n    metadata: [false, false], // lite SDK doesn't return metadata\n    path: snapshot.ref.path,\n    exists,\n  };\n\n  if (exists) {\n    out.data = objectToWriteable(snapshot.data() || {});\n  }\n\n  return out;\n}\n\n// Converts a Firestore query snapshot to a plain object.\nfunction querySnapshotToObject(snapshot) {\n  return {\n    source: 'get',\n    excludesMetadataChanges: true, // lite SDK doesn't return metadata changes\n    changes: [],\n    metadata: [false, false], // lite SDK doesn't return metadata\n    documents: snapshot.docs.map(documentSnapshotToObject),\n  };\n}\n\nconst emulatorForApp = {};\nconst firestoreInstances = {};\nconst appInstances = {};\nconst transactionHandler = {};\nconst transactionBuffer = {};\n\nfunction getCachedAppInstance(appName) {\n  return (appInstances[appName] ??= getApp(appName));\n}\n\nfunction createFirestoreKey(appName, databaseId) {\n  return `${appName}:${databaseId}`;\n}\n\n// Returns a cached Firestore instance.\nfunction getCachedFirestoreInstance(appName, databaseId) {\n  const firestoreKey = createFirestoreKey(appName, databaseId);\n  let instance = firestoreInstances[firestoreKey];\n  if (!instance) {\n    instance = getFirestore(getCachedAppInstance(appName), databaseId);\n    if (emulatorForApp[firestoreKey]) {\n      connectFirestoreEmulator(\n        instance,\n        emulatorForApp[firestoreKey].host,\n        emulatorForApp[firestoreKey].port,\n      );\n    }\n    firestoreInstances[firestoreKey] = instance;\n  }\n  return instance;\n}\n\nexport default {\n  /**\n   * Sets the log level for Firestore.\n   * @param {string} logLevel - The log level.\n   */\n  async setLogLevel(logLevel) {\n    if (logLevel === 'debug' || logLevel === 'error') {\n      setLogLevel(logLevel);\n    } else {\n      setLogLevel('silent');\n    }\n  },\n\n  loadBundle() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n\n  clearPersistence() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n\n  /**\n   * Waits for all pending writes to be acknowledged by the backend.\n   * Noop in the lite SDK.\n   * @returns {Promise<null>} An empty promise.\n   */\n  async waitForPendingWrites() {\n    return null;\n  },\n\n  disableNetwork() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n\n  enableNetwork() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n\n  /**\n   * Use the Firestore emulator.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @param {string} host - The emulator host.\n   * @param {number} port - The emulator port.\n   * @returns {Promise<null>} An empty promise.\n   */\n  useEmulator(appName, databaseId, host, port) {\n    return guard(async () => {\n      const firestore = getCachedFirestoreInstance(appName, databaseId);\n      connectFirestoreEmulator(firestore, host, port);\n      const firestoreKey = createFirestoreKey(appName, databaseId);\n      emulatorForApp[firestoreKey] = { host, port };\n    });\n  },\n\n  /**\n   * Initializes a Firestore instance with settings.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @param {object} settings - The Firestore settings.\n   * @returns {Promise<null>} An empty promise.\n   */\n  settings(appName, databaseId, settings) {\n    return guard(() => {\n      const instance = initializeFirestore(getCachedAppInstance(appName), settings, databaseId);\n      firestoreInstances[appName] = instance;\n    });\n  },\n\n  /**\n   * Terminates a Firestore instance.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @returns {Promise<null>} An empty promise.\n   */\n  terminate(appName, databaseId) {\n    return guard(async () => {\n      const firestore = getCachedFirestoreInstance(appName, databaseId);\n      await terminate(firestore);\n      return null;\n    });\n  },\n\n  // Collection\n  namedQueryOnSnapshot() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n\n  collectionOnSnapshot() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n\n  collectionOffSnapshot() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n\n  namedQueryGet() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n\n  /**\n   * Get a collection count from Firestore.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @param {string} path - The collection path.\n   * @param {string} type - The collection type (e.g. collectionGroup).\n   * @param {object[]} filters - The collection filters.\n   * @param {object[]} orders - The collection orders.\n   * @param {object} options - The collection options.\n   * @returns {Promise<object>} The collection count object.\n   */\n  collectionCount(appName, databaseId, path, type, filters, orders, options) {\n    return guard(async () => {\n      const firestore = getCachedFirestoreInstance(appName, databaseId);\n      const queryRef =\n        type === 'collectionGroup' ? collectionGroup(firestore, path) : collection(firestore, path);\n      const query = buildQuery(queryRef, filters, orders, options);\n      const snapshot = await getCount(query);\n\n      return {\n        count: snapshot.data().count,\n      };\n    });\n  },\n\n  /**\n   * Get a collection from Firestore.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @param {string} path - The collection path.\n   * @param {string} type - The collection type (e.g. collectionGroup).\n   * @param {object[]} filters - The collection filters.\n   * @param {object[]} orders - The collection orders.\n   * @param {object} options - The collection options.\n   * @param {object} getOptions - The get options.\n   * @returns {Promise<object>} The collection object.\n   */\n  collectionGet(appName, databaseId, path, type, filters, orders, options, getOptions) {\n    if (getOptions && getOptions.source === 'cache') {\n      return rejectWithCodeAndMessage(\n        'unsupported',\n        'The source cache is not supported in the lite SDK.',\n      );\n    }\n\n    return guard(async () => {\n      const firestore = getCachedFirestoreInstance(appName, databaseId);\n      const queryRef =\n        type === 'collectionGroup' ? collectionGroup(firestore, path) : collection(firestore, path);\n      const query = buildQuery(queryRef, filters, orders, options);\n      const snapshot = await getDocs(query);\n      return querySnapshotToObject(snapshot);\n    });\n  },\n\n  // Document\n  documentOnSnapshot() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n\n  documentOffSnapshot() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n\n  persistenceCacheIndexManager() {\n    return rejectWithCodeAndMessage('unsupported', 'Not supported in the lite SDK.');\n  },\n\n  /**\n   * Get a document from Firestore.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @param {string} path - The document path.\n   * @param {object} getOptions - The get options.\n   * @returns {Promise<object>} The document object.\n   */\n  documentGet(appName, databaseId, path, getOptions) {\n    return guard(async () => {\n      if (getOptions && getOptions.source === 'cache') {\n        return rejectWithCodeAndMessage(\n          'unsupported',\n          'The source cache is not supported in the lite SDK.',\n        );\n      }\n\n      const firestore = getCachedFirestoreInstance(appName, databaseId);\n      const ref = doc(firestore, path);\n      const snapshot = await getDoc(ref);\n      return documentSnapshotToObject(snapshot);\n    });\n  },\n\n  /**\n   * Delete a document from Firestore.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @param {string} path - The document path.\n   * @returns {Promise<null>} An empty promise.\n   */\n  documentDelete(appName, databaseId, path) {\n    return guard(async () => {\n      const firestore = getCachedFirestoreInstance(appName, databaseId);\n      const ref = doc(firestore, path);\n      await deleteDoc(ref);\n      return null;\n    });\n  },\n\n  /**\n   * Set a document in Firestore.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @param {string} path - The document path.\n   * @param {object} data - The document data.\n   * @param {object} options - The set options.\n   * @returns {Promise<null>} An empty promise.\n   */\n  documentSet(appName, databaseId, path, data, options) {\n    return guard(async () => {\n      const firestore = getCachedFirestoreInstance(appName, databaseId);\n      const ref = doc(firestore, path);\n      const setOptions = {};\n      if ('merge' in options) {\n        setOptions.merge = options.merge;\n      } else if ('mergeFields' in options) {\n        setOptions.mergeFields = options.mergeFields;\n      }\n      await setDoc(ref, readableToObject(firestore, data), setOptions);\n    });\n  },\n\n  /**\n   * Update a document in Firestore.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @param {string} path - The document path.\n   * @param {object} data - The document data.\n   * @returns {Promise<null>} An empty promise.\n   */\n  documentUpdate(appName, databaseId, path, data) {\n    return guard(async () => {\n      const firestore = getCachedFirestoreInstance(appName, databaseId);\n      const ref = doc(firestore, path);\n      await updateDoc(ref, readableToObject(firestore, data));\n    });\n  },\n\n  /**\n   * Batch write documents in Firestore.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @param {object[]} writes - The document writes in write batches format.\n   */\n  documentBatch(appName, databaseId, writes) {\n    return guard(async () => {\n      const firestore = getCachedFirestoreInstance(appName, databaseId);\n      const batch = writeBatch(firestore);\n      const writesArray = parseDocumentBatches(firestore, writes);\n\n      for (const parsed of writesArray) {\n        const { type, path } = parsed;\n        const ref = doc(firestore, path);\n\n        switch (type) {\n          case 'DELETE':\n            batch.delete(ref);\n            break;\n          case 'UPDATE':\n            batch.update(ref, parsed.data);\n            break;\n          case 'SET':\n            const options = parsed.options;\n            const setOptions = {};\n            if ('merge' in options) {\n              setOptions.merge = options.merge;\n            } else if ('mergeFields' in options) {\n              setOptions.mergeFields = options.mergeFields;\n            }\n            batch.set(ref, parsed.data, setOptions);\n            break;\n        }\n      }\n\n      await batch.commit();\n    });\n  },\n\n  /**\n   * Get a document from a Firestore transaction.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @param {string} transactionId - The transaction id.\n   * @param {string} path - The document path.\n   * @returns {Promise<object>} The document object.\n   */\n  transactionGetDocument(appName, databaseId, transactionId, path) {\n    if (!transactionHandler[transactionId]) {\n      return rejectWithCodeAndMessage(\n        'internal-error',\n        'An internal error occurred whilst attempting to find a native transaction by id.',\n      );\n    }\n\n    return guard(async () => {\n      const firestore = getCachedFirestoreInstance(appName, databaseId);\n      const docRef = doc(firestore, path);\n      const tsx = transactionHandler[transactionId];\n      const snapshot = await tsx.get(docRef);\n      return documentSnapshotToObject(snapshot);\n    });\n  },\n\n  /**\n   * Dispose a transaction instance.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @param {string} transactionId - The transaction id.\n   */\n  transactionDispose(appName, databaseId, transactionId) {\n    // There's no abort method in the JS SDK, so we just remove the transaction handler.\n    delete transactionHandler[transactionId];\n  },\n\n  /**\n   * Applies a buffer of commands to a Firestore transaction.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @param {string} transactionId - The transaction id.\n   * @param {object[]} commandBuffer - The readable array of buffer commands.\n   */\n  transactionApplyBuffer(appName, databaseId, transactionId, commandBuffer) {\n    if (transactionHandler[transactionId]) {\n      transactionBuffer[transactionId] = commandBuffer;\n    }\n  },\n\n  /**\n   * Begins a Firestore transaction.\n   * @param {string} appName - The app name.\n   * @param {string} databaseId - The database ID.\n   * @param {string} transactionId - The transaction id.\n   * @returns {Promise<null>} An empty promise.\n   */\n  transactionBegin(appName, databaseId, transactionId) {\n    return guard(async () => {\n      const firestore = getCachedFirestoreInstance(appName, databaseId);\n\n      try {\n        await runTransaction(firestore, async tsx => {\n          transactionHandler[transactionId] = tsx;\n\n          emitEvent('firestore_transaction_event', {\n            eventName: 'firestore_transaction_event',\n            body: { type: 'update' },\n            appName,\n            databaseId,\n            listenerId: transactionId,\n          });\n\n          function getBuffer() {\n            return transactionBuffer[transactionId];\n          }\n\n          // Wait for and get the stored buffer array for the transaction.\n          const buffer = await new Promise(resolve => {\n            const interval = setInterval(() => {\n              const buffer = getBuffer();\n              if (buffer) {\n                clearInterval(interval);\n                resolve(buffer);\n              }\n            }, 100);\n          });\n\n          for (const serialized of buffer) {\n            const { path, type, data } = serialized;\n            const docRef = doc(firestore, path);\n\n            switch (type) {\n              case 'DELETE':\n                tsx.delete(docRef);\n                break;\n              case 'UPDATE':\n                tsx.update(docRef, readableToObject(firestore, data));\n                break;\n              case 'SET':\n                const options = serialized.options;\n                const setOptions = {};\n                if ('merge' in options) {\n                  setOptions.merge = options.merge;\n                } else if ('mergeFields' in options) {\n                  setOptions.mergeFields = options.mergeFields;\n                }\n                tsx.set(docRef, readableToObject(firestore, data), setOptions);\n                break;\n            }\n          }\n        });\n\n        emitEvent('firestore_transaction_event', {\n          eventName: 'firestore_transaction_event',\n          body: { type: 'complete' },\n          appName,\n          databaseId,\n          listenerId: transactionId,\n        });\n      } catch (e) {\n        emitEvent('firestore_transaction_event', {\n          eventName: 'firestore_transaction_event',\n          body: { type: 'error', error: getWebError(e) },\n          appName,\n          databaseId,\n          listenerId: transactionId,\n        });\n      }\n    });\n  },\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}